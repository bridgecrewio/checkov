import json
from pathlib import Path
from typing import Dict, Any

import pytest
from mock import AsyncMock, MagicMock
from pytest_mock import MockerFixture

from checkov.common.bridgecrew.bc_source import SourceType
from checkov.common.bridgecrew.platform_integration import BcPlatformIntegration, bc_integration
from checkov.common.bridgecrew.vulnerability_scanning.package_scanner import PackageScanner


@pytest.fixture()
def mock_bc_integration() -> BcPlatformIntegration:
    bc_integration.bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"
    bc_integration.setup_bridgecrew_credentials(
        repo_id="bridgecrewio/checkov",
        skip_fixes=True,
        skip_suppressions=True,
        skip_policy_download=True,
        source=SourceType("Github", False),
        source_version="1.0",
        repo_branch="master",
    )
    return bc_integration


@pytest.fixture()
def scan_result() -> Dict[str, Any]:
    return {
        "repository": "/abs_path/to/app/requirements.txt",
        "passed": True,
        "packages": {"type": "python", "name": "django", "version": "1.2", "path": "/abs_path/to/app/requirements.txt"},
        "complianceIssues": None,
        "complianceDistribution": {"critical": 0, "high": 0, "medium": 0, "low": 0, "total": 0},
        "vulnerabilities": [
            {
                "id": "CVE-2019-19844",
                "status": "fixed in 3.0.1, 2.2.9, 1.11.27",
                "cvss": 9.8,
                "vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                "description": "Django before 1.11.27, 2.x before 2.2.9, and 3.x before 3.0.1 allows account takeover.",
                "severity": "critical",
                "packageName": "django",
                "packageVersion": "1.2",
                "link": "https://nvd.nist.gov/vuln/detail/CVE-2019-19844",
                "riskFactors": ["Critical severity", "Has fix", "Attack complexity: low", "Attack vector: network"],
                "impactedVersions": ["\u003c1.11.27"],
                "publishedDate": "2019-12-18T20:15:00+01:00",
                "discoveredDate": "2019-12-18T19:15:00Z",
                "fixDate": "2019-12-18T20:15:00+01:00",
            }
        ],
        "vulnerabilityDistribution": {"critical": 1, "high": 0, "medium": 0, "low": 0, "total": 0},
    }


def test_setup_scan_twistcli_exists(mocker: MockerFixture, tmp_path: Path):
    # given
    scanner = PackageScanner()

    integration_mock = MagicMock()
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.download_twistcli",
        side_effect=integration_mock,
    )

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    twistcli_path.touch()
    scanner.twistcli_path = twistcli_path

    # when
    scanner.setup_scan()

    # then
    assert twistcli_path.exists()
    integration_mock.assert_not_called()


def test_setup_scan_twistcli_not_exists(mocker: MockerFixture, tmp_path: Path):
    # given
    scanner = PackageScanner()

    def download_twistcli(cli_file_name: Path):
        cli_file_name.touch()

    integration_mock = MagicMock()
    integration_mock.side_effect = download_twistcli
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.download_twistcli",
        side_effect=integration_mock,
    )

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    scanner.twistcli_path = twistcli_path

    # when
    scanner.setup_scan()

    # then
    assert twistcli_path.exists()
    integration_mock.assert_called_once_with(twistcli_path)


def test_cleanup_scan_twistcli_exists(tmp_path: Path):
    # given
    scanner = PackageScanner()

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    twistcli_path.touch()
    scanner.twistcli_path = twistcli_path

    # when
    scanner.cleanup_scan()

    # then
    assert not twistcli_path.exists()


def test_cleanup_scan_twistcli_not_exists(tmp_path: Path):
    # given
    scanner = PackageScanner()

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    scanner.twistcli_path = twistcli_path

    # when
    scanner.cleanup_scan()

    # then
    assert not twistcli_path.exists()


@pytest.mark.asyncio
async def test_run_scan(mocker: MockerFixture, tmp_path: Path, mock_bc_integration, scan_result):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=0)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=0)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # prepare local paths
    app_temp_dir = tmp_path / "app"
    app_temp_dir.mkdir()
    output_path = app_temp_dir / "requirements_result.json"
    output_path.write_text(json.dumps(scan_result))

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=app_temp_dir / "requirements.txt",
        output_path=output_path,
    )

    # then
    assert result == 0
    assert not output_path.exists()
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_awaited_once()


@pytest.mark.asyncio
async def test_run_scan_fail_on_scan(mocker: MockerFixture, mock_bc_integration):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=1)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=0)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=Path("app/requirements.txt"),
        output_path=Path("app/requirements_result.json"),
    )

    # then
    assert result == 1
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_not_awaited()


@pytest.mark.asyncio
async def test_run_scan_fail_on_report(mocker: MockerFixture, tmp_path: Path, mock_bc_integration, scan_result):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=0)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=1)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # prepare local paths
    app_temp_dir = tmp_path / "app"
    app_temp_dir.mkdir()
    output_path = app_temp_dir / "requirements_result.json"
    output_path.write_text(json.dumps(scan_result))

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=app_temp_dir / "requirements.txt",
        output_path=output_path,
    )

    # then
    assert result == 1
    assert not output_path.exists()
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_awaited_once()
