import json
from pathlib import Path

import pytest
from mock import AsyncMock, MagicMock
from pytest_mock import MockerFixture

from checkov.common.bridgecrew.vulnerability_scanning.package_scanner import PackageScanner


def test_setup_scan_twistcli_exists(mocker: MockerFixture, tmp_path: Path):
    # given
    scanner = PackageScanner()

    integration_mock = MagicMock()
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.download_twistcli",
        side_effect=integration_mock,
    )

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    twistcli_path.touch()
    scanner.twistcli_path = twistcli_path

    # when
    scanner.setup_scan()

    # then
    assert twistcli_path.exists()
    integration_mock.assert_not_called()


def test_setup_scan_twistcli_not_exists(mocker: MockerFixture, tmp_path: Path):
    # given
    scanner = PackageScanner()

    def download_twistcli(cli_file_name: Path):
        cli_file_name.touch()

    integration_mock = MagicMock()
    integration_mock.side_effect = download_twistcli
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.download_twistcli",
        side_effect=integration_mock,
    )

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    scanner.twistcli_path = twistcli_path

    # when
    scanner.setup_scan()

    # then
    assert twistcli_path.exists()
    integration_mock.assert_called_once_with(twistcli_path)


def test_cleanup_scan_twistcli_exists(tmp_path: Path):
    # given
    scanner = PackageScanner()

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    twistcli_path.touch()
    scanner.twistcli_path = twistcli_path

    # when
    scanner.cleanup_scan()

    # then
    assert not twistcli_path.exists()


def test_cleanup_scan_twistcli_not_exists(tmp_path: Path):
    # given
    scanner = PackageScanner()

    # prepare local paths
    twistcli_path = tmp_path / "twistcli"
    scanner.twistcli_path = twistcli_path

    # when
    scanner.cleanup_scan()

    # then
    assert not twistcli_path.exists()


@pytest.mark.asyncio
async def test_run_scan(mocker: MockerFixture, tmp_path: Path, mock_bc_integration, scan_result):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=0)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=0)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # prepare local paths
    app_temp_dir = tmp_path / "app"
    app_temp_dir.mkdir()
    output_path = app_temp_dir / "requirements_result.json"
    output_path.write_text(json.dumps(scan_result))

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=app_temp_dir / "requirements.txt",
        output_path=output_path,
    )

    # then
    assert result == 0
    assert not output_path.exists()
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_awaited_once()


@pytest.mark.asyncio
async def test_run_scan_fail_on_scan(mocker: MockerFixture, mock_bc_integration):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=1)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=0)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=Path("app/requirements.txt"),
        output_path=Path("app/requirements_result.json"),
    )

    # then
    assert result == 1
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_not_awaited()


@pytest.mark.asyncio
async def test_run_scan_fail_on_report(mocker: MockerFixture, tmp_path: Path, mock_bc_integration, scan_result):
    # given
    bc_api_key = "abcd1234-abcd-1234-abcd-1234abcd1234"

    subprocess_async_mock = AsyncMock()
    subprocess_async_mock.return_value.wait = AsyncMock(return_value=0)
    mocker.patch("asyncio.create_subprocess_shell", side_effect=subprocess_async_mock)
    report_results_async_mock = AsyncMock(return_value=1)
    mocker.patch(
        "checkov.common.bridgecrew.vulnerability_scanning.integrations.package_scanning.package_scanning_integration.report_results_async",
        side_effect=report_results_async_mock,
    )

    # prepare local paths
    app_temp_dir = tmp_path / "app"
    app_temp_dir.mkdir()
    output_path = app_temp_dir / "requirements_result.json"
    output_path.write_text(json.dumps(scan_result))

    # when
    result = await PackageScanner().run_scan(
        command="./twistcli coderepo scan",
        bc_platform_integration=mock_bc_integration,
        bc_api_key=bc_api_key,
        input_path=app_temp_dir / "requirements.txt",
        output_path=output_path,
    )

    # then
    assert result == 1
    assert not output_path.exists()
    subprocess_async_mock.assert_awaited_once()
    report_results_async_mock.assert_awaited_once()
